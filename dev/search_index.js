var documenterSearchIndex = {"docs":
[{"location":"man/consensus/#consensus-phylogenies","page":"consensus","title":"consensus phylogenies","text":"","category":"section"},{"location":"man/consensus/#consensus-of-phylogenetic-trees","page":"consensus","title":"consensus of phylogenetic trees","text":"Given a set of input phylogenies that are all trees, we can get their greedy consensus or their majority-rule consensus with consensustree.\n\nTo give an example, we will use a set of trees from an example file that comes with the package:\n\nusing PhyloNetworks\ninputfile = joinpath(dirname(pathof(PhyloSummaries)), \"..\",\"test\",\"raxmltrees.tre\");\ntreesample = readmultinewick(inputfile);\nlength(treesample) # 30 trees\ntreesample[1] # first tree in the list\n\nTo visualize trees and network, we use package PhyloPlots.\n\nusing PhyloPlots\nusing RCall            # to tweak our plot within R\n\nR\"svg\"(figname(\"raxmltree_12.svg\"), width=7, height=3) # hide\nR\"layout\"([1 2])       # figure of 2 panels\nR\"par\"(mar=[0,0,1,0])  # for smaller margins\nplot(treesample[1], showedgelength=true);\nR\"mtext\"(\"tree 1\")     # add text annotation: title here\nplot(treesample[2], showedgelength=true);\nR\"mtext\"(\"tree 2\")\nR\"dev.off()\"; # hide\nnothing # hide\n\n(Image: trees 1-2, from raxml.tre)\n\nBy default, we get the greedy consensus tree of our input trees, considered as unrooted trees.\n\ncon = consensustree(treesample)\nwritenewick(con, support=true)\n\nTo plot the consensus tree showing support values, we can first extract the support values into a data frame, then use it to label edges. Below, we multiple support values by 100 to get percentages.\n\nusing DataFrames\nesup = DataFrame(\n    number = [e.number for e in con.edge if !isexternal(e)],\n    support = [round(100 * e.y, digits=1) for e in con.edge if !isexternal(e)]\n)\necol = Dict(r[:number] => (r[:support] < 70 ? \"orange2\" : \"black\") for r in eachrow(esup))\n\nR\"svg\"(figname(\"raxmltree_con.svg\"), width=7, height=3) # hide\nR\"layout\"([1 2])  # hide\nR\"par\"(mar=[0,0,1,0])  # hide\nplot(con, showedgenumber=true);\nR\"mtext\"(\"edge numbers\", line=0)\nplot(con, edgelabel=esup, edgecolor=ecol);\nR\"mtext\"(\"support: % input trees\", line=0)\nR\"dev.off()\"; # hide\nnothing # hide\n\n(Image: majority rule consensus tree)","category":"section"},{"location":"lib/public/#public-documentation","page":"public","title":"public documentation","text":"Documentation for PhyloSummaries's public (exported) functions. Most functions are internal (not exported).","category":"section"},{"location":"lib/public/#functions-and-types","page":"public","title":"functions & types","text":"","category":"section"},{"location":"lib/public/#index","page":"public","title":"index","text":"Pages = [\"public.md\"]","category":"section"},{"location":"lib/public/#PhyloSummaries.consensustree-Tuple{AbstractVector{PhyloNetworks.HybridNetwork}}","page":"public","title":"PhyloSummaries.consensustree","text":"consensustree(trees::AbstractVector{PN.HybridNetwork};\n              rooted=false,\n              proportion=0,\n              supportaslength=false)\n\nConsensus tree summarizing the bipartitions (or clades) shared by more than the required proportion of input trees. An ArgumentError is thrown if one input network is not a tree, or the list of input trees is empty, or if the input trees do not all have the same tip labels. Input trees are not modified.\n\nOutput: consensus tree as an object of type HybridNetwork.\n\nThe bipartition (or clade) support values are stored\n\nas edge length with option supportaslength=true (not by default).\nin the field .y of each internal edge (as external edges correspond to trivial bipartitions, which must necessarily be in all sampled trees). This field is used by writenewick to write edge support, with its option support=true. However, this .y field is internal, so it can be modified by other functions and should not be relied upon.\nSupport values are also stored in each node .fvalue for the clade descendant from that node. Note that storing support values at nodes is unsafe for unrooted bipartitions, as the bipartition associated with the node's descendants given some rooting may become one of node's child subclade after re-rooting.\n\nBy default, input trees are considered unrooted, and bipartitions are considered. Use rooted=true to consider all input trees as rooted, in which case clades (rather than bipartitions) are used to build the output rooted consensus tree.\n\nBy default, the greedy consensus consensus is calculated: the tree is built from the bipartitions (or clades) with the highest support, until no more can be added. The majority-rule tree can be obtained by using proportion=0.5: it is built only from bipartitions (or clades) present in more than 50% of the input trees.\n\nassumptions and warnings:\n\nInput trees are assumed to have their edges correctly directed. If unsure, run directedges!.(trees) prior.\nInput trees should not have degree-2 nodes other than the root (nodes with 1 only parent and 1 child). If unsure, run removedegree2nodes!.(trees, true)) to keep their root even of degree 2 or removedegree2nodes!.(trees, false)) unroot them also.\n\nfixit: make a future version summarize edge lengths in input trees and store their average in the consensus tree.\n\nexample\n\njulia> nwk = [\"((c,d),((a1,a2),b));\", \"(((a2,a1),b),c,d);\", \"(((a1,a2),c),d,b);\"];\n\njulia> treesample = readnewick.(nwk);\n\njulia> con = consensustree(treesample); writenewick(con, round=true, support=true)\n\"(c,d,(b,(a1,a2)::1.0)::0.667);\"\n\njulia> con = consensustree(treesample; rooted=true); # greedy consensus\n\njulia> writenewick(con, round=true, support=true)\n\"((d,c)::0.333,(b,(a1,a2)::1.0)::0.667);\"\n\njulia> [e.number => round(e.y, digits=3) for e in con.edge if !isexternal(e)] # edge number -> support\n3-element Vector{Pair{Int64, Float64}}:\n 6 => 0.333\n 7 => 0.667\n 8 => 1.0\n\njulia> con = consensustree(treesample; rooted=true, proportion=0.5); # majority-rule\n\njulia> writenewick(con, round=true, support=true)\n\"(c,d,(b,(a1,a2)::1.0)::0.667);\"\n\njulia> con = consensustree(treesample; proportion=0.75, supportaslength=true) |> writenewick\n\"(b,c,d,(a2,a1):1.0);\"\n\n\n\n\n\n","category":"method"},{"location":"#PhyloSummaries","page":"home","title":"PhyloSummaries","text":"PhyloSummaries is a Julia package with tools to summarize features of a phylogenetic networks, and features shared across a sample of multiple phylogenetic networks.\n\n","category":"section"},{"location":"#references","page":"home","title":"references","text":"See them in bibtex format.","category":"section"},{"location":"#manual","page":"home","title":"manual","text":"The manual pages contain detailed tutorials on how to use functions in the package.\n\nPages = [\n    \"man/installation.md\",\n    \"man/consensus.md\",\n]\nDepth = 3","category":"section"},{"location":"#library","page":"home","title":"library","text":"For help on individual functions, see this library.\n\nPages = [\n    \"lib/public.md\",\n    \"lib/internal.md\",\n]\nDepth = 3","category":"section"},{"location":"lib/internal/#internal-documentation","page":"internal","title":"internal documentation","text":"Documentation for PhyloSummaries's internal functions. These functions are not exported and their access (API) should not be considered stable. But they can still be used, like this for example: PhyloSummaries.foo() for a function named foo().","category":"section"},{"location":"lib/internal/#functions-and-types","page":"internal","title":"functions & types","text":"","category":"section"},{"location":"lib/internal/#index","page":"internal","title":"index","text":"Pages = [\"internal.md\"]","category":"section"},{"location":"lib/internal/#PhyloSummaries.consensus_bipartitions!-Tuple{Dictionaries.Dictionary{<:NTuple{N, Bool} where N, Int64}, Number, Number}","page":"internal","title":"PhyloSummaries.consensus_bipartitions!","text":"consensus_bipartitions!(splitcounts::Dictionary{<:SplitTuple,Int},\n    proportion::Number, numtrees::Number)\n\nFilter dictionary splitcounts to keep only the entries whose frequency (count value in the dictionary) are greater than proportion × numtrees, or equal to numtrees when proportion is 1. Bipartitions with frequency weight over 50% must be compatible with each other. Bipartitions are retained one by one, from most to least frequent, so long as they are compatible with bipartititions previously kept.\n\nThe result can be passed to tree_from_bipartitions to construct the associated consensus tree topology. proportion = 1 corresponds to the strict consensus tree, proportion = 0.5 corresponds to the majority-rule consensus tree and proportion = 0 to a greedy consensus tree.\n\nOutput: splitcounts modified, with some entries filtered out, and sorted by frequency (from least to most frequent) if proportion<0.5.\n\nAssumption: all counts are positive.\n\nExample\n\njulia> using Dictionaries\n\njulia> bp = [(true,false), (false,false), (true,true)]; freq=(3,1,4);\n\njulia> splitcounts = dictionary(zip(bp, freq))\n3-element Dictionary{Tuple{Bool, Bool}, Int64}:\n  (true, false) │ 3\n (false, false) │ 1\n   (true, true) │ 4\n\njulia> PhyloSummaries.consensus_bipartitions!(splitcounts, 0.5, 4)\n2-element Dictionary{Tuple{Bool, Bool}, Int64}:\n (true, false) │ 3\n  (true, true) │ 4\n\njulia> splitcounts = dictionary(zip(bp, freq)); # reset as earlier\n\njulia> PhyloSummaries.consensus_bipartitions!(splitcounts, 0, 4)\n3-element Dictionary{Tuple{Bool, Bool}, Int64}:\n (false, false) │ 1\n  (true, false) │ 3\n   (true, true) │ 4\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloSummaries.count_bipartitions!-Tuple{Dictionaries.Dictionary{<:NTuple{N, Bool} where N, Int64}, PhyloNetworks.HybridNetwork, Vector{String}, Bool}","page":"internal","title":"PhyloSummaries.count_bipartitions!","text":"count_bipartitions!(counts, net, taxa, rooted)\n\nCount bipartitions in net, and add them to counts. If a new bipartition is found, a new key is added to counts with value 1. If net has a bipartition already present as a key in counts, then the corresponding value is incremented by 1. net is not modified.\n\nBy default, input trees are considered unrooted, and bipartitions are considered. Use rooted=true to consider all input trees as rooted, in which case clades (rather than bipartitions) are used to build the output rooted consensus tree.\n\nOnly non-trivial (not all 0s or all 1s) splits contribute to the count totals. \n\nIf the tip labels in net do not match those in taxa (as a set), then an error will be thrown indirectly (via PhyloNetworks.hardwiredclusters).\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloSummaries.tree_from_bipartitions-Tuple{Vector{String}, Dictionaries.Dictionary{NTuple{N, Bool} where N, <:Number}, Number, Bool}","page":"internal","title":"PhyloSummaries.tree_from_bipartitions","text":"tree_from_bipartitions(taxa::Vector{String},\n    clusters::Dictionary{SplitTuple,<:Number},\n    ntrees::Number,\n    supportaslength::Bool)\n\nConstruct a consensus tree from a compatible set of cluster, as a PhyloNetworks.HybridNetwork object. Each cluster is represented as a tuple key b, and is given a weight: its value clusters[b] divided by ntrees. For each cluster, a node is added to the consensus tree, whose descendant taxa is the set taxa[i] for indices i such that b[i] is true. The cluster's weight is stored in the node's .fvalue –-which is fragile, if clusters are to be considered as unrooted bipartitions. The weight is also stored in fields of the node's parent edge: .length and .y.\n\nAssumption: the input clusters are pairwise tree-compatible, which is the condition for them to be the clusters of a valid rooted tree.\n\nUsed by: consensustree\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloSummaries.treecompatible-Tuple{NTuple{N, Bool} where N, NTuple{N, Bool} where N}","page":"internal","title":"PhyloSummaries.treecompatible","text":"treecompatible(a::SplitTuple, b::SplitTuple)\n\ntrue / false if two clusters a and b are / are not tree-compatible.\n\nIf A is the cluster of descendants of a (with true entries in a) and if B is the cluster of descendant of b, these 2 clusters are tree-compatible if there exists some tree that has both clusters. This can be checked by the condition: A∩B is empty, or A⊆B, or B⊆A.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#PhyloSummaries.tuple_from_clustervector-Tuple{AbstractVector, Bool}","page":"internal","title":"PhyloSummaries.tuple_from_clustervector","text":"tuple_from_clustervector(cluster01vector, rooted)\n\nTuple of booleans t with t[i] true / false if taxa[i] does / does not belong in the hardwired cluster vector cluster01vector of 0/1 integers; or nothing if the cluster is trivial (all 0s or all 1s).\n\nIf rooted is false, then clusters are considered as bipartitions and the last taxon is used as an outgroup with a false entry. For example, clusters 0011 and 1100 represent the same bipartition, and both would return tuple (true,true,false,false).\n\n\n\n\n\n","category":"method"},{"location":"man/installation/#installation","page":"installation","title":"installation","text":"To install Julia, see here.\n\nTo read & write phylogenies (networks or trees, admixture graphs), you should install PhyloNetworks, which PhyloSummaries depends on. To install it, see here.\n\nTo visualize phylogenies, install PhyloPlots. We can do so in the Julia REPL for example: enter package mode with ], and:\n\nadd PhyloPlots\n\nOr in julian mode:\n\nusing Pkg\nPkg.add(\"PhyloPlots\")","category":"section"}]
}
